<!DOCTYPE html>
<html lang="en"> 
<head>
  <meta charset="utf-8" />
	<title>The code is saying[.js]</title>
	<link rel='stylesheet' href='/style.css' type='text/css' media='all' />
	<link rel='stylesheet' href='./style.css' type='text/css' media='all' />
</head>
  <body>
    <h3>The code is saying[.js]</h3>
    <p>A dynamic version of this piece is forthcoming. For the moment here is node.js code that represents a slightly revised version of the piece as first published in <cite>Run Run Run</cite> (ed. Nick Monfort, New York: Bad Quarto, 2025, p. 8). To see the generator in action please just copy and paste this code into a file that must be named ‘saying.js’ (because it loads itself as data). With node.js installed on your system, open a terminal, navigate to the folder with the saying.js file and run with:<br>
    <code>> node saying.js</code></p>

    <code>
    const theSayable=require('fs')
    let whatIAmGenerating=theSayable.readFileSync("saying.js",'utf-8')
    let thinking=0,movements="",dwelling=""
    const recognitions=[["="," being "],["RegExp",
    "regular expression"],["stdout","saying"],["replace",
    "replacing"],["write","writing"],["[^\\w]"," "],
    ["([A-Z])"," $1"],["const ","constantly "],["fs","memory"
    ],["File","archive"],["aeiou","vowels"],["utf","language"],
    ["floor","ground"],["length","extension"],[" +"," "]]
    const moving=(qualities,here,there)=>
    qualities=qualities.replace(new RegExp(here,"g"),there)
    function continualMovement(theLifeWorldReading,recognitions){
     for(const reading of recognitions){
      theLifeWorldReading=moving(theLifeWorldReading,reading[0],reading[1])}
     return theLifeWorldReading}
    function expressing(imagining){
     let writing=[]
     for(const images of imagining){
      if(images.match(/[aeiou]/))writing.push(images)}
     return writing}
    whatIAmGenerating=continualMovement(whatIAmGenerating,recognitions)
    whatIAmGenerating=expressing(whatIAmGenerating.split(" "))
    let horizon=whatIAmGenerating.length
    while(thinking++ &lt;horizon){
     do{movements=whatIAmGenerating[Math.floor(Math.random()*horizon)]}
     while(dwelling==movements)
     dwelling=movements
     process.stdout.write(movements+" ")}
    </code>
    <hr>
    <input type="file" id="fileInput">
    <hr>
    <!-- DISPLAY HTML -->
    <div id="container">
      <div id="scroll0" class="scroller"></div>
      <div id="scroll1" class="scroller"></div>
      <div id="scroll2" class="scroller"></div>
      <div id="scroll3" class="scroller"></div>
      <div id="scroll4" class="scroller"></div>
      <div id="scroll5" class="scroller"></div>
      <div id="scroll6" class="scroller"></div>
      <div id="mask"></div>
    </div>
    <div>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</div>
    <!-- SCRIPT -->
    <script type="module">
      // CONFIG
      import {saying} from "./saying.js";
      const spanRegex = /^<span[^>]*>.*?<\/span>/;
      const numOfLines = 7, wordsPerLine = 11;
      let whatIAmGenerating;
      //
      document.addEventListener('DOMContentLoaded', () => {
        const fileInput = document.getElementById('fileInput');
        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0]; // Get the selected file
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              if (e.target.result) {
                whatIAmGenerating = saying(e.target.result);
                main(whatIAmGenerating);
              }
            };
            reader.readAsText(file); // Read the file as text
          }
        });
      });
      async function main(whatIAmGenerating) {
        console.log("now scroll ...");
        let prevWord = "";
        for (let i = 0; i < numOfLines; i++) {
          let elem = document.getElementById("scroll" + i);
          let html = "";
          let spanned = "";
          for (let j = 0; j < wordsPerLine; j++) {
            [spanned, prevWord] = getWord(prevWord);
            html += spanned;
          }
          elem.innerHTML = html;
        }
        scrollGeneration(prevWord);
      }
      function getWord (prevWord) {
        let word;
        do {
          word = whatIAmGenerating[Math.floor(Math.random()*whatIAmGenerating.length)].toLowerCase();
        } while (word == prevWord)
        return [span(word), word];
      }
      function span (word) {
        return `<span>${word} </span>`;
      }
      async function scrollGeneration(prevWord = "") {
        console.log("entering scrollGeneration");
        let count = 0, spanned = "";
        while (count++ < 100) { // EDIT
          console.log("big loop", `${count} of 100`);
          // if (!scrollContainer.firstChild) throw new Error("Element with first child not found");
          // else console.log("firstChild", scrollContainer.firstChild);
          let lineScrollers = [];
          [spanned, prevWord] = getWord(prevWord);
          for (let i = numOfLines - 1; i > -1; i--) {
            const scrollContainer = document.getElementById("scroll" + i);
            lineScrollers.push(scrollFirstWord(scrollContainer));
            // console.log("innerHTML before", scrollContainer.innerHTML); // DEBUG
            let inner = scrollContainer.innerHTML;
            let head = inner.match(spanRegex);
            let decapitated = inner.replace(head[0],"");
            scrollContainer.innerHTML = decapitated + spanned;
            console.log(i, scrollContainer.innerText); // DEBUG
            // if (!(i == (numOfLines - 1))) {
            spanned = head[0];
              // let prevContainer = document.getElementById("scroll" + (i - 1));
              // inner = prevContainer.innerHTML;
              // prevContainer.innerHTML = inner + head[0];
              // prevContainer.scrollLeft = 0;
            // }
            scrollContainer.scrollLeft = 0;
          }
          await Promise.all(lineScrollers);
          // console.log("innerHTML after", scrollContainer.innerHTML); // DEBUG
          // let redraw = scrollContainer.offsetWidth;
          // scrollContainer.append(firstWord); // EDIT append!
          // console.log("after append", scrollContainer);
          // redraw = scrollContainer.offsetWidth;
          // if (!scrollContainer)
            // throw new Error("Element of scrollContainer not found");
          // DEBUG theContainer.insertBefore(scrollContainer, theContainer.firstChild);
          // NEEDED IN OBSERVABLE: displayCell.insertBefore(scrollContainer, displayCell.firstChild);
        }
        return;
      }
      async function scrollFirstWord(scrollContainer) {
        const wordToScroll = scrollContainer.firstChild;
        if (!wordToScroll) throw new Error("Element with first word not found");
        const amountToScroll = wordToScroll.offsetWidth;
        let tries = 0, maxTries = 1000; // Prevent infinite loop
        return new Promise((resolve) => {
          function smoothScroll() {
            tries++;
            if (scrollContainer.scrollLeft >= amountToScroll || tries > maxTries) {
              if (tries > maxTries) {
                console.warn("scrollFirstWord: maxTries reached", {amountToScroll, scrollLeft: scrollContainer.scrollLeft});
              }
              resolve();
            } else {
              scrollContainer.scrollBy({
                left: 1.5,
                behavior: "instant"
              });
              requestAnimationFrame(smoothScroll);
            }
          }
          smoothScroll();
        });
      }
    </script>
  </body>
</html>
