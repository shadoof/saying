<!DOCTYPE html>
<html lang="en"> 
<head>
  <meta charset="utf-8" />
	<title>The code is saying[.js]</title>
	<link rel='stylesheet' href='/style.css' type='text/css' media='all' />
	<link rel='stylesheet' href='./style.css' type='text/css' media='all' />
</head>
  <body>
    <h3>The code is saying[.js]</h3>
    <p>A dynamic version of this piece is forthcoming. For the moment here is node.js code that represents a slightly revised version of the piece as first published in <cite>Run Run Run</cite> (ed. Nick Monfort, New York: Bad Quarto, 2025, p. 8). To see the generator in action please just copy and paste this code into a file that must be named ‘saying.js’ (because it loads itself as data). With node.js installed on your system, open a terminal, navigate to the folder with the saying.js file and run with:<br>
    <code>> node saying.js</code></p>

    <code>
    const theSayable=require('fs')
    let whatIAmGenerating=theSayable.readFileSync("saying.js",'utf-8')
    let thinking=0,movements="",dwelling=""
    const recognitions=[["="," being "],["RegExp",
    "regular expression"],["stdout","saying"],["replace",
    "replacing"],["write","writing"],["[^\\w]"," "],
    ["([A-Z])"," $1"],["const ","constantly "],["fs","memory"
    ],["File","archive"],["aeiou","vowels"],["utf","language"],
    ["floor","ground"],["length","extension"],[" +"," "]]
    const moving=(qualities,here,there)=>
    qualities=qualities.replace(new RegExp(here,"g"),there)
    function continualMovement(theLifeWorldReading,recognitions){
     for(const reading of recognitions){
      theLifeWorldReading=moving(theLifeWorldReading,reading[0],reading[1])}
     return theLifeWorldReading}
    function expressing(imagining){
     let writing=[]
     for(const images of imagining){
      if(images.match(/[aeiou]/))writing.push(images)}
     return writing}
    whatIAmGenerating=continualMovement(whatIAmGenerating,recognitions)
    whatIAmGenerating=expressing(whatIAmGenerating.split(" "))
    let horizon=whatIAmGenerating.length
    while(thinking++ &lt;horizon){
     do{movements=whatIAmGenerating[Math.floor(Math.random()*horizon)]}
     while(dwelling==movements)
     dwelling=movements
     process.stdout.write(movements+" ")}
    </code>
    <hr>
    <input type="file" id="fileInput">
    <hr>
    <!-- DISPLAY HTML -->
    <div id="container">
      <div id="scroll0" class="scroller"></div>
      <div id="scroll1" class="scroller"></div>
      <div id="scroll2" class="scroller"></div>
      <div id="scroll3" class="scroller"></div>
      <div id="scroll4" class="scroller"></div>
      <div id="scroll5" class="scroller"></div>
      <div id="scroll6" class="scroller"></div>
      <div id="mask"></div>
    </div>
    <div>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;</div>
    <!-- SCRIPT -->
    <script type="module">
      // CONFIG
      import {saying} from "./saying.js";
      const spanRegex = /^<span[^>]*>.*?<\/span>/;
      const numOfLines = 7, wordsPerLine = 10;
      const longTail = "<span>" + "&nbsp;".repeat(100) + "</span>";
      let whatIAmGenerating;
      //
      document.addEventListener('DOMContentLoaded', () => {
        const fileInput = document.getElementById('fileInput');
        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0]; // Get the selected file
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              if (e.target.result) {
                whatIAmGenerating = saying(e.target.result);
                main(whatIAmGenerating);
              }
            };
            reader.readAsText(file); // Read the file as text
          }
        });
      });
      // MAIN FUNCTION
      async function main(whatIAmGenerating) {
        console.log("Main function started");
        // populate the scroll elements with words
        let prevWord = "";
        for (let i = 0; i < numOfLines; i++) {
          let elem = document.getElementById("scroll" + i);
          let html = "";
          let spanned = "";
          for (let j = 0; j < wordsPerLine; j++) {
            [spanned, prevWord] = await getWord(prevWord);
            html += spanned;
          }
          elem.innerHTML = html + longTail;
        }
        for (let i = numOfLines - 1; i > -1; i--) {
          if (i === numOfLines - 1) {
            scrollFirstWord(document.getElementById("scroll" + i), getWord, prevWord, i);
          } else {
            scrollFirstWord(document.getElementById("scroll" + i), getHead, prevWord, i);
          }
        }
      }
      async function scrollFirstWord(scrollContainer, wordSource, prevWord = "", lineNum, speed = 20) {
        let spanned = "";
        const spanRegex = /^<span[^>]*>(.*?)<\/span>/;
        while (true) {
          const wordToScroll = scrollContainer.firstChild;
          if (!wordToScroll) throw new Error("Element with first word not found");
          const amountToScroll = wordToScroll.offsetWidth;
          let tries = 0, maxTries = 1000;
          await new Promise((resolve) => {
            function smoothScroll() {
              tries++;
              colorSpansByOffset(); // COLOR SPANS
              if (scrollContainer.scrollLeft >= amountToScroll || tries > maxTries) {
                resolve();
              } else {
                scrollContainer.scrollBy({
                  left: 1,
                  behavior: "instant"
                });
                setTimeout(smoothScroll, speed);
              }
            }
            smoothScroll();
          });
          let inner = scrollContainer.innerHTML;
          let head = inner.match(spanRegex);
          let decapitated = inner.replace(head[0], "").replace(longTail, "");
          let children = scrollContainer.children;
          let tail = children[children.length - 2];
          prevWord = tail.innerHTML.trim();
          console.log("Tail outerHTML:", tail.outerHTML); // DEBUG
          [spanned, prevWord] = await wordSource(prevWord, lineNum);
          scrollContainer.innerHTML = decapitated + spanned + longTail;
          scrollContainer.scrollLeft = 0;
          await new Promise(r => setTimeout(r, speed)); // Wait for the next scroll
        }
      }
      function getHead(prevWord, lineNum) {
        console.log("getHead called with prevWord:", prevWord);
        const spanRegex = /^<span[^>]*>(.*?)<\/span>/;
        return new Promise((resolve, reject) => {
          let inner = document.getElementById("scroll" + (lineNum + 1)).innerHTML;
          let spanned = inner.match(spanRegex);
          if (!spanned) {
            reject(new Error("No span found in next line"));
            return;
          }
          if (spanned[1].trim() !== prevWord) {
            console.log("spanned[1]:", spanned[1]);
            resolve([spanned[0], prevWord]);
          } else {
            // Try again after a short delay
            setTimeout(() => {
              resolve(getHead(prevWord, lineNum));
            }, 10);
          }
        });
      }
      function getWord(prevWord) {
        console.log("getWord called with prevWord:", prevWord);
        return new Promise((resolve) => {
          let word;
          function tryWord() {
            word = whatIAmGenerating[Math.floor(Math.random() * whatIAmGenerating.length)].toLowerCase();
            if (word !== prevWord) {
              resolve([span(word), word]);
            } else {
              setTimeout(tryWord, 0); // Try again asynchronously
            }
          }
          tryWord();
        });
      }
      function span (word) {
        return `<span>${word} </span>`;
      }
      function colorSpansByOffset() {
        const scrollDiv = document.getElementById("scroll3");
        const spans = scrollDiv.querySelectorAll("span");
        const leftEdge = 250, rightEdge = 700;
        spans.forEach(span => {
          const offset = span.offsetLeft;
          if (offset > leftEdge && offset < rightEdge) {
            span.classList.add("red");
          } else if (offset < leftEdge || offset > rightEdge) {
            span.classList.remove("red");
          }
        });
      }
    </script>
  </body>
</html>
